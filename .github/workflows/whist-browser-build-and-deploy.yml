# workflows/whist-browser-build-and-deploy.yml
#
# Whist Browser: Build & Deploy
# Build and deploy the Whist Browser, built from our own fork of Brave and our Whist monorepo.

name: "Whist Browser: Build & Deploy"

on:
  # On dev, we run a nightly build on weekdays (days of the week 1-5) at 00:01 UTC.
  schedule:
    - cron: "1 0 * * 1,2,3,4,5"
  # On staging & prod, we run a build for each promotion (push to branch).
  push:
    branches:
      - main
      - phil/deploy-pipeline # TODO: FOR TESTING, DELETE ONCE DONE
    paths-ignore:
      - "README.md"
      - "**/README.md"
      - ".github/workflows/README.md"
  workflow_dispatch:
    inputs:
      target:
        type: choice
        required: true
        description: |
          The target deployment environment to which the chosen ref
          should be deployed. The target deployment environment
          should be one of "dev", "staging", or "prod". The default
          target deployment environment is "dev".
        options:
          - dev
          - staging
          - prod
        default: dev
      dry-run:
        type: boolean
        description: |
          A boolean indicating whether or not to perform a dry run
          deployment. If this boolean is set, code will be built, but
          not deployed. The default is "true", to avoid accidental
          deployment mistakes.
        required: true
        default: true

concurrency:
  group: whist-browser-build-and-deploy-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

jobs:
  # This job builds the Whist Browser for a specific OS and architecture by starting the build on the GHA machine
  # and offloading the build to a Goma cluster via EngFlow.
  whist-browser-build-and-deploy:
    name: "Build & Deploy Whist Browser for ${{ matrix.config.target_os }} (${{ matrix.config.target_arch}})"
    runs-on: [self-hosted, macOS, ARM64]



    # TODO: figure out how to reconcile the deploy with the backend, maybe look at how chrome does its deploys
    # there will also be huge downtime if we do it sequentially, so we need to avoid that


    strategy:
      matrix:
        config:
          - target_arch: "x86_64"
            target_os: "macOS"
          - target_arch: "arm64"
            target_os: "macOS"

    # TODO: Add those buckets to Terraform in whisthq/whist monorepo
    env:
      x64-binary-tar-name: whist-browser-macos-x64.tar.gz
      x64-s3-bucket-uri: s3://whist-browser-macos-x64
      arm64-binary-tar-name: whist-browser-macos-arm64.tar.gz
      arm64-s3-bucket-uri: s3://whist-browser-macos-arm64
      s3-bucket-region: us-east-1

    steps:
      # TODO: Make the macOS runner use the proper keychain
      - name: Checkout Git Repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}

      - name: Authenticate with GitHub (for pulling the required repositories)
        env:
          GH_USERNAME: ${{ secrets.GHA_USERNAME }}
          GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
        run: git config --global url.https://$GH_USERNAME:$GH_PAT@github.com/.insteadOf https://github.com/


      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh false

      - name: Configure AWS S3 CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.s3-bucket-region }}




      ############################# Windows Configuration Steps START #############################

      - name: Install cmake via Chocolatey on Windows GHA Machine
        if: runner.os == 'Windows'
        uses: crazy-max/ghaction-chocolatey@v2
        with:
          args: install cmake --pre --no-progress --installargs 'ADD_CMAKE_TO_PATH=System'

      - name: Set up Visual Studio Developer Command Prompt (for nmake)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      #############################################################################################
      ############################### Unix Configuration Steps START ##############################

      - name: Install macOS Codesigning Certificates on macOS GHA Machine
        if: runner.os == 'macOS'
        uses: apple-actions/import-codesign-certs@v1
        with:
          p12-file-base64: ${{ secrets.MACOS_SIGNING_P12_CERTIFICATES_BASE64_ENCODED }}
          p12-password: ${{ secrets.MACOS_SIGNING_P12_CERTIFICATES_BASE64_ENCODED_PASSWORD }}

      # This step follows the specs in https://github.com/electron/electron-notarize#notes-on-jwt-authentication
      - name: Install macOS Notarization API Key
        if: runner.os == 'macOS'
        run: |
          mkdir -p ~/private_keys
          aws s3 cp s3://whist-dev-secrets/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8 ~/private_keys




      # Building Brave/Chromium requires specific Node & npm versions, and Xcode. For full
      # details, see: https://github.com/whisthq/brave-browser#readme
      - name: Log NodeJS, NPM and Xcode Versions
        run: |
          # Source .bashrc file to set up the environment for the build
          source ~/.bashrc

          echo "Force NodeJS version 16 and NPM version 8.5.0..."
          npm install -g npm@8.5.0
          nvm use 16

          echo ""
          echo "Verifying NodeJS & NPM versions (need 16.x and 8.5.0)..."
          node --version
          npm --version

          echo ""
          echo "Verifying that Xcode is installed and up-to-date (Need 13.x)..."
          xcodebuild -version

      - name: Initialize the Build Environment
        run: npm install

      - name: Configure Build Type
        run: |
          if [[ "${{ github.event.inputs.target }}" == "prod" ]]; then
            # Production build, set official build as true and build Chromium as Release
            npm config set is_official_build=true
            echo "build_type=Release" >> $GITHUB_ENV
          else
            # Dev or Staging build, set official build as false and build Chromium as Debug
            npm config set is_official_build=false
            echo "build_type=Debug" >> $GITHUB_ENV
          fi

      - name: Retrieve Current Whist Browser Version from Config Database
        run: |
          ACCESS_KEY='${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}'

          # curl GraphQL API to retrieve version number from config database
          curl -X POST \
          -H "Content-Type: application/json" \
          -H "X-Hasura-Admin-Secret: $ACCESS_KEY" \
          --data "{ \"query\": \"query { desktop_app_version { major minor micro dev_rc staging_rc } }\" }" \
          https://config-database.whist.com/v1/graphql > response.json

          # Check if we actually got back valid JSON. If not, we should throw
          # a human-readable error because the config DB might be down.
          if cat response.json | jq -e . > /dev/null 2>&1; then
            echo "Got some valid JSON from the config DB:"
            cat response.json
            echo
            echo "Continuing..."
          else
            echo "Failed to parse the JSON from the config DB. Is it up?" && false
          fi

          # parse JSON into major.minor.micro-rc
          MAJOR=$(cat response.json | jq '.data.desktop_app_version[0].major')
          MINOR=$(cat response.json | jq '.data.desktop_app_version[0].minor')
          MICRO=$(cat response.json | jq '.data.desktop_app_version[0].micro')
          DEV_RC=$(cat response.json | jq '.data.desktop_app_version[0].dev_rc')
          STAGING_RC=$(cat response.json | jq '.data.desktop_app_version[0].staging_rc')

          # remove temporary JSON file
          rm response.json

          echo "Current prod version: $MAJOR.$MINOR.$MICRO"
          echo "Current staging version: $MAJOR.$MINOR.$MICRO-staging-rc.$STAGING_RC"
          echo "Current dev version: $MAJOR.$MINOR.$MICRO-dev-rc.$DEV_RC"

          # if dev or staging, increment RC by 1, else increment micro by 1 and set RC to 0
          if [[ "${{ github.event.inputs.target }} | " == "prod" ]]; then
            echo 'Using prod configuration...'
            # increment version by 0.0.1
            NEW_MICRO=$(echo "print( ${MICRO} + 1)" | python3)

            # set new desktop app version
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_MICRO}"

            # store NEW_MICRO in GITHUB_ENV to push to GraphQL API, and reset STAGING_RC and DEV_RC to 0
            echo "new_micro_version=${NEW_MICRO}" >> $GITHUB_ENV
            echo "new_staging_rc_version=0" >> $GITHUB_ENV
            echo "new_dev_rc_version=0" >> $GITHUB_ENV
          elif [[ "${{ github.event.inputs.target }}" == "staging" ]]; then
            echo 'Using staging configuration...'
            # increment version by staging-rc.1
            NEW_STAGING_RC=$(echo "print( ${STAGING_RC} + 1)" | python3)

            # set temporary variable for upcoming micro version which is 1 ahead of current, since
            # staging/dev are release candiates (rc) for the next version. We don't push that micro
            # version to GraphQL in staging/dev, only on prod when it becomes current
            UPCOMING_MICRO=$(echo "print( ${MICRO} + 1)" | python3)

            # set new desktop app version
            NEW_VERSION="${MAJOR}.${MINOR}.${UPCOMING_MICRO}-staging-rc.${NEW_STAGING_RC}"

            # store NEW_STAGING_RC in GITHUB_ENV to push to GraphQL API
            echo "new_staging_rc_version=${NEW_STAGING_RC}" >> $GITHUB_ENV
          else
            echo 'Using dev configuration...'
            # increment version by dev-rc.1
            NEW_DEV_RC=$(echo "print( ${DEV_RC} + 1)" | python3)

            # set temporary variable for upcoming micro version which is 1 ahead of current, since
            # staging/dev are release candiates (rc) for the next version. We don't push that micro
            # version to GraphQL in staging/dev, only on prod when it becomes current
            UPCOMING_MICRO=$(echo "print( ${MICRO} + 1)" | python3)

            # set new desktop app version [-x64/-arm64] gets appended depending on the OS architecture it is built on
            NEW_VERSION="${MAJOR}.${MINOR}.${UPCOMING_MICRO}-dev-rc.${NEW_DEV_RC}"

            # store NEW_DEV_RC in GITHUB_ENV to push to GraphQL API
            echo "new_dev_rc_version=${NEW_DEV_RC}" >> $GITHUB_ENV
          fi

          # store new desktop app version as GitHub step output to substitute in GitHub Release tag creation
          echo "New ${{ github.event.inputs.target }} version: ${NEW_VERSION}"
          echo "release_version=${NEW_VERSION}" >> $GITHUB_ENV

      # We need to configure build parameters, to build for the proper architecture and with
      # the relevant flags for the selected build type. Note that we cannot/don't want to use
      # a lot of Brave-specific services, which are either omitted or filled-in blank.
      #
      # List of potential flags can be found here:
      # https://github.com/whisthq/brave-core/blob/main/build/commands/lib/config.js#L77
      # https://github.com/brave/brave-core/blob/master/build/commands/scripts/commands.js#L71
      - name: Configure Build Parameters
        run: |
          # Set architecture and version
          # TODO: Retrieve version from configDB (can reuse code in whist-build-and-deploy.yml once we are ready)
          npm config set target_arch=${{ matrix.config.target_arch }}
          npm config set target_os=${{ matrix.config.target_os }}
          npm config set version=${{ env.release_version }}

          # Google Auth integration
          # TODO: These GitHub Secrets are currently the values from the Whist Electron Application
          # GCP project. Once we transition from Electron to Chromium officially, we'll want to sunset
          # that GCP project and configure Google Auth within the Whist Chromium Browser GCP project.
          # EDIT: They were not added organization wide in github secrets so i had to remove them, they need
          # to be recreated
          npm config set google_default_client_id=${{ secrets.WHIST_CHROMIUM_GOOGLE_CLIENT_ID }}
          npm config set google_default_client_secret=${{ secrets.WHIST_CHROMIUM_GOOGLE_CLIENT_SECRET }}

          # Google APIs, the key is from the Whist Chromium Browser GCP project
          npm config set brave_google_api_key=${{ secrets.WHIST_CHROMIUM_GOOGLE_API_KEY }}
          npm config set safebrowsing_api_endpoint=https://safebrowsing.googleapis.com/v4/...?key=${{ secrets.WHIST_CHROMIUM_GOOGLE_API_KEY }}

          # TODO: Configure update server
          # TODO: Add support for staging update server
          npm config set updater_dev_endpoint=https://
          npm config set updater_prod_endpoint=https://
          npm config set updater_prod_endpoint=https://
          npm config set brave_stats_updater_url=https://

          # TODO: Configure Brave Sync server
          npm config set brave_sync_endpoint=https://

          # Brave Services
          npm config set brave_services_key=somefakekey
          npm config set brave_variations_server_url=https://variations.brave.com/seed
          npm config set webcompat_report_api_endpoin=https://webcompat.brave.com/1/webcompat

          # TODO: Configure Apple Notarization
          # npm config set notary_user=
          # npm config set notary_password=
          # npm config set mac_signing_keychain=login
          # npm config set mac_signing_identifier=
          # npm config set mac_installer_signing_identifier=

          # AMPLITUDE_KEY: ${{ secrets.CLIENTAPP_AMPLITUDE_KEY }}
          # MACOS_ARCH: "${{ matrix.config.arch }}"
          # # These two environment variables must be set as per https://www.npmjs.com/package/electron-builder-notarize#api-key
          # APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          # APPLE_API_KEY_ISSUER_ID: ${{ secrets.APPLE_API_KEY_ISSUER_ID }}


          # These are all related to Brave rewards/crypto, which we don't care about/cannot use, so 
          # we provide dummy values
          npm config set uphold_client_id=fake
          npm config set uphold_client_secret=fake
          npm config set gemini_wallet_client_id=fake
          npm config set gemini_wallet_client_secret=fake
          npm config set gemini_api_url=https://
          npm config set gemini_oauth_url=https://
          npm config set rewards_grant_dev_endpoint=https://
          npm config set rewards_grant_staging_endpoint=https://
          npm config set rewards_grant_prod_endpoint=https://

      - name: Fetch Chromium Source & Dependencies
        run: npm run init

      # Use all 20 Mac Studio threads
      - name: Build Whist Browser
        run: npm run build ${{ env.build_type }} -j 20




        # Each final build has an internal build id and debug id. Sentry will use these
        # IDs to match the debug symbols with the build that crashed to build the backtrace
      - name: Copy Client debug symbols to Sentry, on macOS
        if: runner.os == 'macOS'
        working-directory: frontend/client-applications
        env:
          SENTRY_ORG: whist
          SENTRY_PROJECT: protocol
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
        run: |
          curl -sL https://sentry.io/get-cli/ | bash
          sentry-cli upload-dif WhistProtocolClient/build/WhistClient
          sentry-cli upload-dif WhistProtocolClient/debugSymbols/WhistClient.debug

        # Each final build has an internal build id and debug id. Sentry will use these
        # IDs to match the debug symbols with the build that crashed to build the backtrace
      - name: Copy Client debug symbols to Sentry, on Windows
        if: runner.os == 'Windows'
        working-directory: frontend/client-applications
        env:
          SENTRY_ORG: whist
          SENTRY_PROJECT: protocol
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          # We specify INSTALL_DIR first, so the sentry-cli script doesn't try to call `sudo`
          export INSTALL_DIR=$GITHUB_WORKSPACE
          curl -sL https://sentry.io/get-cli/ | bash
          D:/a/whist/whist/sentry-cli upload-dif WhistProtocolClient/build/WhistClient
          D:/a/whist/whist/sentry-cli upload-dif WhistProtocolClient/debugSymbols/WhistClient.debug






      - name: Update Config Database Version with the New Version
        run: |
          ACCESS_KEY='${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}'

          # curl GraphQL API to set new micro/staging_rc/dev_rc version number and git commit hash in config database
          if [[ "${{ github.event.inputs.target }}" == "prod" ]]; then
            curl -X POST \
            -H "Content-Type: application/json" \
            -H "X-Hasura-Admin-Secret: $ACCESS_KEY" \
            --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {micro: ${{ env.new_micro_version }}, staging_rc: ${{ env.new_staging_rc_version }}, dev_rc: ${{ env.new_dev_rc_version }}, prod_commit_hash: \\\"${{ github.sha }}\\\"}) { id } }\" }" \
            https://config-database.whist.com/v1/graphql
          elif [[ "${{ github.event.inputs.target }}" == "staging" ]]; then
            curl -X POST \
            -H "Content-Type: application/json" \
            -H "X-Hasura-Admin-Secret: $ACCESS_KEY" \
            --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {staging_rc: ${{ env.new_staging_rc_version }}, staging_commit_hash: \\\"${{ github.sha }}\\\"}) { id } }\" }" \
            https://config-database.whist.com/v1/graphql
          elif [[ "${{ github.event.inputs.target }}" == "dev" ]]; then
            curl -X POST \
            -H "Content-Type: application/json" \
            -H "X-Hasura-Admin-Secret: $ACCESS_KEY" \
            --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {dev_rc: ${{ env.new_dev_rc_version }}, dev_commit_hash: \\\"${{ github.sha }}\\\"}) { id } }\" }" \
            https://config-database.whist.com/v1/graphql
          fi

      - name: Tar & Upload Whist Browser to AWS S3
        run: |
          tar -zcvf "${{ matrix.config.target_arch }}-binary-tar-name" "Component_${{ matrix.config.target_arch }}/Brave Browser" "${{ env.build_type }}.app"
          aws s3 cp "${{ matrix.config.target_arch }}-binary-tar-name" "${{ matrix.config.target_arch }}-s3-bucket-uri/${{ matrix.config.arch }}-binary-tar-name"

      ###################################################################################

      - name: Notify Slack on Workflow Error (Only on Push/Workflow_dispatch Events)
        if: failure()
        shell: python3 {0}
        run: |
          from notifications.slack_bot import slack_post
          SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"
          BODY = f"@releases :rotating_light: Failed to deploy Whist Browser to AWS S3, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

      - name: Notify Slack on Success
        if: success()
        shell: python3 {0}
        run: |
          from notifications.slack_bot import slack_post
          SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"
          TITLE = ":brave: Whist Browser Deployed :brave:"
          BODY = f"Whist Browser deployed to AWS S3 (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

    # TODO: Once we fully move off of Electron, we should merge this with the whist-build-and-deploy` workflow,
    # and publish GitHub Tags



  #######################################################################################
  #######################################################################################

  # Create GitHub Tag
  # Create a GitHub Tag when promoting to the `prod` branch
  # Runs if the entire deployment succeeds and the promotion is running on `prod`
  whist-create-github-release-tag:
    name: "Create GitHub Release Tag"
    runs-on: ubuntu-20.04
    needs:
      [
        whist-publish-build-config,
        auth0-deploy-rules,
        terraform-deploy,
        mandelboxes-publish-ghcr,
        amis-publish-aws,
        scaling-service-deploy,
        client-applications-retrieve-version-number,
        client-applications-publish-build-s3,
        client-applications-update-version-number,
      ]
    if: needs.whist-publish-build-config.outputs.publish == 'true' && contains(fromJSON('["prod"]'), needs.whist-publish-build-config.outputs.branch)
    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Retrieve Today's Date
        run: echo "date=$(date)" >> $GITHUB_ENV

      - name: Create GitHub Tag
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.client-applications-retrieve-version-number.outputs.release_version }}
          body: Whist Production Release on ${{ env.date }}
          draft: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify Slack on Job Success
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          TITLE = ":github: Whist GitHub Release Completed :github:"
          BODY = "Deployment of Whist Version `v${{ needs.client-applications-retrieve-version-number.outputs.release_version }}` on branch `${{ needs.whist-publish-build-config.outputs.branch }}` completed - See the generated GitHub Release here: https://github.com/whisthq/whist/releases/tag/v${{ needs.client-applications-retrieve-version-number.outputs.release_version }} (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

      - name: Notify Slack on Job Error
        if: failure()
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          BODY = "@releases :rotating_light: Deployment failed: could not create GitHub Release in `whist-create-github-release-tag` job, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)




